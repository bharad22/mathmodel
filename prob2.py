# -*- coding: utf-8 -*-
"""Prob2_MM

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n_2TqlQkCEneqjafFHS-kok2o-jg_v0z

#Global functions and imports
"""

import matplotlib.pyplot as plt
import random
import pprint
import math
import scipy.stats as stats
from statistics import mean
from scipy import interpolate

def forward_difference(arr):
  forward_diff_table=[]
  while len(arr)>1:
    temp=[]
    for i in range(1,len(arr)):
      temp.append(arr[i]-arr[i-1])
    forward_diff_table.append(temp)
    arr = temp
  return forward_diff_table

def ncr(n, r, forward):
  val = 1
  for i in range(r):
    if forward == True:
      val *= (n - i)
    else:
      val *= (n + i)
  if r == 1:
    return val
  a = val / math.factorial(r)
  
  return a

def interpolation(y, n, fdt, u, forward):
  val = y
  if forward == True:
    for i in range(n):
      val += ncr(u, i+1, True) * fdt[i][0]
  else:
    for i in range(n):
      val += ncr(u, i+1, False) * fdt[i][-1]

  return val

def newton_divided_difference(x,y,n):
  divided_difference = [[0 for i in range(10)] 
        for j in range(10)]

  for i in range(n):
    divided_difference[i][0]=y[i]
    
  for i in range(1, n): 
    for j in range(n - i): 
        divided_difference[j][i] = ((divided_difference[j][i - 1] - divided_difference[j + 1][i - 1]) /(x[j] - x[i + j]));
  return divided_difference

def previous_term(i, value, x): 
    prev = 1; 
    for j in range(i): 
        prev = prev * (value - x[j]); 
    return prev;

def newton_formula(value, x, y, n): 
  
    sum_temp = y[0][0]; 
  
    for i in range(1, n):
        sum_temp = sum_temp + (previous_term(i, value, x) * y[0][i]); 
      
    return sum_temp;

def lagrange_interpolation(x,y,x_val):
  res=0
  for i in range(len(x)):
    numr=1
    denr = 1
    for j in range(len(x)):
      if j!=i:
        numr *= (x_val - x[j])
        denr *= (x[i] - x[j])
    res += ((numr/denr)*y[i])

  return res

"""#Problem 1

    The cost of government welfare programs adds significantly to our taxes. The following table gives 
    the data between 1985 to1995 (in billions)
    years	1985	1986	1987	1988	1989	1990	1991	1992	1993	1994	1995
    Expen.   731	 782	 833	 886	 956	 1049	1159	1267	1367	1436	1505

    (i) Find  and plot the corresponding interpolating polynomial 
    (ii)Find the interpolating polynomial using the data 1985 to 1993 and hence calculate the 
    values of 1994 and 1995 and compare with given values
    (iii) Used appropriate statistical test to check whether the polynomial fits the data?

"""

year = [1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995]
exp = [731, 782, 833, 886, 956, 1049, 1159, 1267, 1367, 1436, 1505]

del_exp = forward_difference(exp)
print(del_exp)
fig = plt.figure(figsize = (12, 8))
for index, i in enumerate(del_exp):
  plt.plot(year[:len(i)], i, label = str(index))

plt.legend()
plt.show()

h=1

y_cap = []
for i in range(len(year)):
  u = (year[i]-year[0])/h
  y_cap.append(interpolation(exp[0], len(del_exp), del_exp, u, True))
plt.figure(figsize = (12, 8))
plt.plot(year, y_cap, 'o', year, y_cap)
plt.show()

year=[1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993]

exp=[731, 782, 833, 886, 956, 1049, 1159, 1267, 1367]

forward_diff_table = forward_difference(exp)
year_x=[1994,1995]
h=1

y_cap = []
for i in range(len(year_x)):
  if abs(year_x[i] - year[0]) < abs(year_x[i] - year[-1]):
    u = (year_x[i]-year[0])/h
    y_cap.append(interpolation(exp[0], len(forward_diff_table), forward_diff_table, u, True))
  else:
    u = (year_x[i]-year[-1])/h
    y_cap.append(interpolation(exp[0], len(forward_diff_table), forward_diff_table, u, False))
plt.plot(year_x, y_cap)
plt.show()

"""#Problem 2

    The emittance of tungsten as a function temperature e(T)=0.02424(T/303.16)^1.27591. 
    The following data gives the emittance a various temperature.
    (i) Construct the interpolating polynomial and compare with the original result 
    (ii) Plot both the curves.

    T	300	400	 500	  600	  700	  800	  900	  1000	 1100
    e	0.024  0.035   0.046	0.058	0.067	0.083	0.097	0.111	0.125

    T	1200   1300	1400	 1500	 1600	 1700	 1800	 1900	 2000
    e	0.140  0.155   0.170	0.186	0.202	0.219	0.235	0.252	0.269

"""

t = [300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000]
e = [0.024, 0.035, 0.046, 0.058, 0.067, 0.083, 0.097, 0.111, 0.125, 0.140, 0.155, 0.170, 0.186, 0.202, 0.219, 0.235, 0.252, 0.269]

forward_diff_table = forward_difference(e)

h = 100
y_cap = []
error=[]
for i in range(len(t)):
  u = (t[i]-t[0])/h
  y_cap.append(interpolation(e[0], len(forward_diff_table), forward_diff_table, u, True))
  error.append(y_cap[-1]-e[i])

plt.plot(t, y_cap, label = "t versus interpolation", linewidth = 5)
plt.plot(t, e, label = "t versus e")
plt.legend()
plt.show()

"""#Problem 3

    Compute the value of f(x) at x=  0.5, 3 using 
    (i)  Newton divided difference  formula
    (ii) Lagrangeâ€™s interpolation formula.
"""

x=[0,1,2,5.5,11,13,16,18]
y=[0.5, 3.134, 5.3, 9.9, 10.2, 9.35,7.2,6.2]


x_val=[0.5,3]
divi_diff = newton_divided_difference(x,y,len(x))
y_cap=[]
for i in x_val:
  y_cap.append(newton_formula(i,x,divi_diff,len(x)))

print("Newton divided difference: ", y_cap)

x=[0,1,2,5.5,11,13,16,18]
y=[0.5, 3.134, 5.3, 9.9, 10.2, 9.35,7.2,6.2]

x_val = [0.5,3]
y_cap=[]
for i in x_val:
  y_cap.append(lagrange_interpolation(x,y,i))

print("Lagrange interpolation   : ", y_cap)

"""#Problem 4

    The following data defines the sea-level concentration of dissolved oxygen for fresh water as a function of temperature:

    T |    0        8       16      24      32      40 
    o | 14.621   11.843   9.870   8.418   7.305   6.413

    (i)  Obtain the cubic spline functions and plot the curves
    (ii) Calculate the value of o at T = 4 and 36
"""