# -*- coding: utf-8 -*-
"""Mathematical Modelling 4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xgCgaZMiuRAn5tSCe45tJ0-zFzV1UHDw

## WORKSHEET 4 - Analysis of Stock Data (Nestle)
"""

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")

stock_df = pd.read_csv("500790.csv")
stock_df

stock_prices_df = stock_df[["Open Price", "High Price", "Low Price"]]

shape = stock_prices_df.shape
print("Dataset contains {} rows and {} columns".format(shape[0],shape[1]))

stock_prices_df.describe()

x = stock_df.iloc[:, 1:4]
y = stock_df.iloc[:, 4]

x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.2,random_state=0)

#shapes of splitted data
print("X_train:",x_train.shape)
print("X_test:",x_test.shape)
print("Y_train:",y_train.shape)
print("Y_test:",y_test.shape)

linreg=LinearRegression()
linreg.fit(x_train,y_train)

y_pred=linreg.predict(x_test)

Accuracy=r2_score(y_test,y_pred)*100
print(" Accuracy of the model is %.2f" %Accuracy)

plt.scatter(y_test,y_pred);
plt.xlabel('Actual');
plt.ylabel('Predicted');

sns.regplot(x=y_test,y=y_pred,ci=None,color ='red');

"""Predicting Close from Open"""

pred_df=pd.DataFrame({'Actual Value':y_test,'Predicted Value':y_pred,'Difference':y_test-y_pred})
pred_df

"""##Moving Average Model

### Utility Functions
"""

def predict_val(b0, b1, x):
  return [b0 + b1 * i for i in x]

def ComputeSeasonalIndex(x, num_yrs):
  four_quarter_moving_avg = []
  four_quarter_centered_moving_avg = []
  percent_actual_to_moving_avg = []
  j = 0

  for i in range(len(x)-3):
    temp = (x[i] + x[i+1] + x[i+2] + x[i+3]) / 4
    four_quarter_moving_avg.append(temp)

  print("\nFour quarter moving averages: ", four_quarter_moving_avg)

  for i in range(len(four_quarter_moving_avg)-1):
    temp = (four_quarter_moving_avg[i] + four_quarter_moving_avg[i+1]) / 2
    four_quarter_centered_moving_avg.append(temp)

  print("\nFour quarter centered moving averages: ", four_quarter_centered_moving_avg)

  for i in range(2, len(x)-2):
    temp = (x[i] / four_quarter_centered_moving_avg[j]) * 100
    j += 1
    percent_actual_to_moving_avg.append(temp)

  print("\nPercentage of actual to moving averages: ", percent_actual_to_moving_avg)

  diff = [0, 0] + percent_actual_to_moving_avg
  n = len(diff) % 4
  diff += [0 for i in range(n)]

  print("\nDiff values: ", diff)

  track = []
  modified_mean = []
  width = len(diff) // num_yrs

  for i in range(4):
    temp = []

    for j in range(0, num_yrs):
      temp.append(diff[width*j+i])

    track.append(temp)
  
  print("\nTrack values: ", track)

  for i in range(len(track)):
    track[i] = [i for i in track[i] if i != 0]
    a = min(track[i])
    b = max(track[i])
    track[i].remove(a)
    track[i].remove(b)
    n = len(track[i])
    modified_mean.append(sum(track[i]) / n)

  print("\nModified means / Trimmed means: ", modified_mean)

  tot = sum(modified_mean)
  adjusting_factor = 400 / tot
  seasonal_indices = []

  for i in range(len(modified_mean)):
    seasonal_indices.append(modified_mean[i] * adjusting_factor)

  print("\nSeasonal indices: ", seasonal_indices)

  modified_seasonal_indices = [i/100 for i in seasonal_indices]
  modified_seasonal_indices = modified_seasonal_indices * num_yrs

  deseasonalized_data = []

  for i in range(len(x)):
    deseasonalized_data.append((x[i] / modified_seasonal_indices[i]))

  print("\nDeseasonalized data: ", deseasonalized_data)

  ans_dict = {'four_quarter_moving_avg':four_quarter_moving_avg, 'four_quarter_centered_moving_avg':four_quarter_centered_moving_avg, 'percent_actual_to_moving_avg':percent_actual_to_moving_avg, 'diff':diff, 'track':track, 'modified_mean':modified_mean, 'seasonal_indices':seasonal_indices, 'deseasonalized_data':deseasonalized_data}

  return ans_dict
def IdentifyTrend(x, num_yrs):
  n = len(x)
  coding = [0 for i in range(n)]

  mid = (n//2) - 1
  coding[mid] = -0.5
  coding[mid+1] = 0.5

  for i in range(mid-1, -1, -1):
    coding[i] = coding[i+1] - 1

  for i in range(mid+2, n):
    coding[i] = coding[i-1] + 1

  for i in range(n):
    coding[i] *= 2

  xy = [i*j for i,j in zip(coding, x)]
  x_2 = [i**2 for i in coding]

  sum_y = sum(x)
  sum_x_2 = sum(x_2)
  sum_xy = sum(xy)

  print("\nSummation y: ", sum_y)
  print("\nSummation xy: ", sum_xy)
  print("\nSummation x2: ", sum_x_2)

  b = sum_xy / sum_x_2
  a = sum_y / (num_yrs * 4)

  ans_dict = {'a':a, 'b':b, 'coding':coding}
  
  return ans_dict

"""### Open Price"""

#5 year Stock Data 
df = stock_df[0:60]
data = np.array(df[['Open Price']])
finData = data.transpose()[0]

print(finData)
# Merging as quarters
data = [(finData[i] + finData[i+1] + finData[i+2]) / 3 for i in range(0, len(data), 3)]
print(data)
re = ComputeSeasonalIndex(data, 5)

coeff = IdentifyTrend(re['deseasonalized_data'], 5)

YCap = predict_val(coeff['a'], coeff['b'], coeff['coding'])

trend = [round((re['deseasonalized_data'][i] / YCap[i]) * 100, 5) for i in range(len(YCap))]
relativeTrend = [round(((re['deseasonalized_data'][i] - YCap[i]) / YCap[i]) * 100, 5) for i in range(len(YCap))]

print("Trend", trend)
print("Relative Trend", relativeTrend)
plt.figure(figsize=(13, 10))
plt.title('Trend plot')
plt.plot(data, label="actual")
plt.plot(YCap, label="Predicted")
plt.plot(re['deseasonalized_data'], '--', label="deseasonalized")
plt.legend()
plt.show()

def Arma(p, q, dataColumn):
  # AR
  reg = LinearRegression()
  n = len(dataColumn)
  Y = np.array([dataColumn[i: n-p+i] for i in range(p+1)])[::-1]
  y, x = Y[0].transpose(), Y[1:].transpose()

  reg.fit(x,y)
  y_pred=reg.predict(x)
  residual = np.subtract(y, y_pred)
  print("AR equation", np.array([reg.coef_[0], reg.coef_[1], reg.intercept_]))
  
  # MA
  reg = LinearRegression()
  n = len(residual)
  X = np.array([residual[i: n-q+i] for i in range(q+1)])[::-1]
  y, x = X[0].transpose(), X[1:].transpose()

  reg.fit(x,y)
  print("MA equation", np.array([reg.coef_[0], reg.coef_[1], reg.intercept_]))
  
data = np.array(df[['Close Price']])
finData = data.transpose()[0]
Arma(2, 2, finData)

