# -*- coding: utf-8 -*-
"""Math Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17GshI8y-x-DwsGnKa9Nv8IuG_fF1rzCF

# Mathematical Modelling

### Imports
"""

import matplotlib.pyplot as plt
from math import factorial
import numpy as np
import math
from scipy import stats, interpolate

"""### Utility Functions """

def ForwardInterpolationTable(arr):
  table =[]
  while len(arr) > 1:
    rowInst = [arr[i] - arr[i-1] for i in range(1, len(arr))]
    arr = rowInst
    table.append(rowInst)

  return table

def comb(n, r, forward = True):
  val = 1
  for i in range(r):
    val *= ((n-i) if forward else (n+i))
  return val if r == 1 else val / math.factorial(r)

def ForwardInterpolationPolynomial(initY, fInrTable, u):
  re = initY
  for i in range(len(fInrTable)): 
    re += comb(u, i+1) * fInrTable[i][0]
  return re

def BackwardInterpolationPolynomial(initY, fInrTable, u):
  re = initY
  for i in range(len(fInrTable)):
    re += comb(u, i+1, False) * fInrTable[i][-1]
  return re

def LagrangeInterpolation(x,y,x_val):
  re = 0
  for i in range(len(x)):
    numerator=1
    denominator = 1
    for j in range(len(x)):
      if j!=i:
        numerator *= (x_val - x[j])
        denominator *= (x[i] - x[j])
    re += ((numerator/denominator)*y[i])

  return re

def NewtonDividedDifference(x,y,n):
  divided_difference = [[0 for i in range(10)] 
        for j in range(10)]

  for i in range(n):
    divided_difference[i][0]=y[i]
    
  for i in range(1, n): 
    for j in range(n - i): 
        divided_difference[j][i] = ((divided_difference[j][i - 1] - divided_difference[j + 1][i - 1]) /(x[j] - x[i + j]));
  return divided_difference

def NewtonFormula(value, x, y, n):
  def previous_term(i, value, x): 
    prev = 1; 
    for j in range(i): 
        prev = prev * (value - x[j]); 
    return prev;
  
  sum_temp = y[0][0]; 

  for i in range(1, n):
      sum_temp = sum_temp + (previous_term(i, value, x) * y[0][i]); 
    
  return sum_temp;

def LinearRegression(x, y):
  n = len(x)
  xy = np.dot(np.array(x), np.array(y))

  x_sq = 0
  for i in x:
    x_sq += i**2


  a = (((n*xy) - (sum(x)*sum(y))) /((n*x_sq) - (pow(sum(x),2))))
  b = ((sum(y) -(a*sum(x)))/n)

  return a,b

def CalculateMeasures(y, y_cap):
  n = len(y)
  sse = 0
  sst = 0
  y_bar = sum(y)/n
  for i in range(n):
    diff = y[i] - y_cap[i]
    sse += (y[i] - y_cap[i]) * (y[i] - y_cap[i])
    sst += (y[i] - y_bar) * (y[i] - y_bar)

  correlation = 1-(sse/sst)
  return sse, sst, correlation

def predict_val(b0, b1, x):
  return [b0 + b1 * i for i in x]

def ComputeSeasonalIndex(x, num_yrs):
  
  four_quarter_moving_avg = []
  four_quarter_centered_moving_avg = []
  percent_actual_to_moving_avg = []
  j = 0

  for i in range(len(x)-3):
    temp = (x[i] + x[i+1] + x[i+2] + x[i+3]) / 4
    four_quarter_moving_avg.append(temp)

  print("\nFour quarter moving averages: ", four_quarter_moving_avg)

  for i in range(len(four_quarter_moving_avg)-1):
    temp = (four_quarter_moving_avg[i] + four_quarter_moving_avg[i+1]) / 2
    four_quarter_centered_moving_avg.append(temp)

  print("\nFour quarter centered moving averages: ", four_quarter_centered_moving_avg)

  for i in range(2, len(x)-2):
    temp = (x[i] / four_quarter_centered_moving_avg[j]) * 100
    j += 1
    percent_actual_to_moving_avg.append(temp)

  print("\nPercentage of actual to moving averages: ", percent_actual_to_moving_avg)

  diff = [0, 0] + percent_actual_to_moving_avg
  n = len(diff) % 4
  diff += [0 for i in range(n)]

  print("\nDiff values: ", diff)

  track = []
  modified_mean = []
  width = len(diff) // num_yrs

  for i in range(4):
    temp = []

    for j in range(0, num_yrs):
      temp.append(diff[width*j+i])

    track.append(temp)
  
  print("\nTrack values: ", track)

  for i in range(len(track)):
    track[i] = [i for i in track[i] if i != 0]
    a = min(track[i])
    b = max(track[i])
    track[i].remove(a)
    track[i].remove(b)
    n = len(track[i])
    modified_mean.append(sum(track[i]) / n)

  print("\nModified means / Trimmed means: ", modified_mean)

  tot = sum(modified_mean)
  adjusting_factor = 400 / tot
  seasonal_indices = []

  for i in range(len(modified_mean)):
    seasonal_indices.append(modified_mean[i] * adjusting_factor)

  print("\nSeasonal indices: ", seasonal_indices)

  modified_seasonal_indices = [i/100 for i in seasonal_indices]
  modified_seasonal_indices = modified_seasonal_indices * num_yrs

  deseasonalized_data = []

  for i in range(len(x)):
    deseasonalized_data.append((x[i] / modified_seasonal_indices[i]))

  print("\nDeseasonalized data: ", deseasonalized_data)

  ans_dict = {'four_quarter_moving_avg':four_quarter_moving_avg, 'four_quarter_centered_moving_avg':four_quarter_centered_moving_avg, 'percent_actual_to_moving_avg':percent_actual_to_moving_avg, 'diff':diff, 'track':track, 'modified_mean':modified_mean, 'seasonal_indices':seasonal_indices, 'deseasonalized_data':deseasonalized_data}

  return ans_dict

def IdentifyTrend(x, num_yrs):
  n = len(x)
  coding = [0 for i in range(n)]

  mid = (n//2) - 1
  coding[mid] = -0.5
  coding[mid+1] = 0.5

  for i in range(mid-1, -1, -1):
    coding[i] = coding[i+1] - 1

  for i in range(mid+2, n):
    coding[i] = coding[i-1] + 1

  for i in range(n):
    coding[i] *= 2

  xy = [i*j for i,j in zip(coding, x)]
  x_2 = [i**2 for i in coding]

  sum_y = sum(x)
  sum_x_2 = sum(x_2)
  sum_xy = sum(xy)

  print("\nSummation y: ", sum_y)
  print("\nSummation xy: ", sum_xy)
  print("\nSummation x2: ", sum_x_2)

  b = sum_xy / sum_x_2
  a = sum_y / (num_yrs * 4)

  ans_dict = {'a':a, 'b':b, 'coding':coding}
  
  return ans_dict

"""## Worksheet1

### Problem1
"""

dynamicalFunc = lambda a, r, m: [[r_val ** i * a for i in range(1, m+1)] for r_val in r]

a, m = [0, 50, 50, 50], 20

rValues = [[0], [i for i in np.arange(0, 1, 0.1)], [i for i in np.arange(-1, 0, 0.1)], [i for i in range(5, 0, -1)] + [i for i in range(1, 6)]]

rTitles = ['r = 0', '0 < r < 1', '-1 < r < 0', '|r| > 1']
fig, axs = plt.subplots(2, 2, figsize=(30, 20))

for i in range(2):
  for j in range(2):
    for k in dynamicalFunc(a[i+j], rValues[i+j], m):
      axs[i, j].plot(k)
    axs[i, j].set_title(rTitles[i+j])

for ax in axs.flat:
    ax.set(xlabel='x-label', ylabel='y-label')

for ax in axs.flat:
    ax.label_outer()

"""### Problem2"""

doses = [0.1, 0.2, 0.3]
plot_points = []

n = 20

def dosageRecursive(x, n):
  arr = [x]
  for i in range(n):
    arr.append(0.5 * arr[-1] + x)
  return arr

fig, axs = plt.subplots(3, figsize=(20, 18))

for index, dose in enumerate(doses):
  arr = dosageRecursive(dose, n)
  axs[index].plot(arr)
  axs[index].set_title(f'Dosage {dose}')

for ax in axs.flat:
    ax.set(xlabel='day', ylabel='dosage')

"""### Problem3"""

n = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])
An = np.array([3,	6,	11,	21,	32,	47,	65,	87,	112,	110,	171,	204,	241,	282,	325,	376])

intervalDiff = 1

fInrTable = ForwardInterpolationTable(An)

fig, axs = plt.subplots(2, figsize=(20, 14))

for index, arr in enumerate(fInrTable):
  axs[0].plot(arr, label = str(index))
axs[0].legend()

axs[0].set_title('del(An) vs n')

error = [\
         ForwardInterpolationPolynomial(An[0], fInrTable, ((n[i]-n[0]) / intervalDiff)) - An[i]\
         for i in range(len(An))\
        ]

axs[1].plot(n, error)
axs[1].set_title('Error')

print(f'Error from n = 16: An({An[15]}) - InterpolationPrediction({ForwardInterpolationPolynomial(An[0], fInrTable, ((n[15]-n[0]) / intervalDiff))}): {An[15] - ForwardInterpolationPolynomial(An[0], fInrTable, ((n[15]-n[0]) / intervalDiff))}\n')

"""### Problem4"""

force = [10, 20, 30, 40, 50, 60, 70, 80, 90]
stretch = np.array([19, 57, 94, 134, 173, 216, 256, 297, 343])

intervalDiff = 10

fInrTable = ForwardInterpolationTable(stretch)

polynomialPredicted = [\
          ForwardInterpolationPolynomial(stretch[0], fInrTable, (force[i] - force[0]) / intervalDiff)\
          for i in range(len(stretch))\
        ]

error = [polynomialPredicted[i] - stretch[i] for i in range(len(polynomialPredicted))]

fig, axs = plt.subplots(2, figsize=(20, 12))

for index, arr in enumerate(fInrTable):
  axs[0].plot(arr, label = str(index))

axs[0].set_title('del(stretch) vs force')
axs[0].legend()

axs[1].plot(force, error)
axs[1].set_title('Force vs error')

toPredict = [15, 17, 85]

predicted = [\
              ForwardInterpolationPolynomial(stretch[0], fInrTable, (toPredict[i] - force[0]) / intervalDiff)\
              for i in range(len(toPredict))\
             ]
print(f'Predicted values from interpolation for {toPredict}: {predicted}\n')

t_value,p_value=stats.ttest_ind(stretch,polynomialPredicted)

print({ 't_value': t_value }, '\n')

"""## Worksheet2

### Problem1
"""

year = [1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995]
expenditure = [731, 782, 833, 886, 956, 1049, 1159, 1267, 1367, 1436, 1505]

intervalDiff = 1

fInrTable = ForwardInterpolationTable(expenditure)

YCap = [ForwardInterpolationPolynomial(expenditure[0], fInrTable, (year[i] - year[0]) / intervalDiff)\
        for i in range(len(year))]

      
fig, axs = plt.subplots(3, figsize=(20, 20))

for index, i in enumerate(fInrTable):
  axs[0].plot(year[:len(i)], i, label = str(index))

axs[0].legend()

axs[1].plot(year, YCap, 'o', year, YCap)
axs[1].set_title('year vs yCap')
axs[1].legend()

# Upto 1993
fInrTable = ForwardInterpolationTable(expenditure[0: -2])

YCap2 = [] 
[ForwardInterpolationPolynomial(expenditure[0], fInrTable, (1994 - year[0]) / intervalDiff),\
        ForwardInterpolationPolynomial(expenditure[0], fInrTable, (1995 - year[0]) / intervalDiff)]

yearX = [1994, 1995]

y = expenditure[-2: ]

for i in range(len(yearX)):
  # When the value is near first half, then forward
  if abs(yearX[i] - year[0]) < abs(yearX[i] - year[-1]):
    print("Forwa")
    YCap2.append(ForwardInterpolationPolynomial(expenditure[0], fInrTable, (yearX[i] - year[0]) / intervalDiff))
  # else backward
  else:
    YCap2.append(BackwardInterpolationPolynomial(expenditure[0], fInrTable, (yearX[i] - year[-1]) / intervalDiff))

axs[2].plot(year[0: -2], YCap[0: -2], color='orange')
axs[2].plot(year[-3:], [YCap[-3]] + YCap2, color='red')
axs[2].scatter(year, expenditure)

print(YCap2)
t, p = stats.ttest_ind(y, YCap)
if(p > 0.95):
  print("\nFitting\n");
else:
  print("\nNot Fitting\n")

"""### Problem2"""

t = [300, 400, 500, 600, 700, 800, 900, 1000, 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000]
e = [0.024, 0.035, 0.046, 0.058, 0.067, 0.083, 0.097, 0.111, 0.125, 0.140, 0.155, 0.170, 0.186, 0.202, 0.219, 0.235, 0.252, 0.269]

intervalDiff = 100
fInrTable = ForwardInterpolationTable(e)

YCap = [ForwardInterpolationPolynomial(e[0], fInrTable, (t[i] - t[0])/ intervalDiff) for i in range(len(t))]
error = [YCap[i] - e[i] for i in range(len(e))]

plt.figure(figsize=(20, 7))
plt.plot(t, YCap, label = "Temperature versus Polynomial", linewidth = 2)
plt.plot(t, error, label = "Temperature versus Error")
plt.legend()
plt.show()

"""### Problem3

"""

x = [0,1,2,5.5,11,13,16,18]
y = [0.5, 3.134, 5.3, 9.9, 10.2, 9.35,7.2,6.2]

x_val=[0.5,3]
divDifference = NewtonDividedDifference(x,y,len(x))

YCap = [NewtonFormula(i, x, divDifference, len(x)) for i in x_val]
print("Newton divided difference: ", YCap)

YCap = [LagrangeInterpolation(x, y, i) for i in x_val]
print("Lagrange interpolation   : ", YCap)

"""### Problem4"""

t = [0, 8, 16, 24, 32, 40]
o = [14.621, 11.843, 9.870, 8.418, 7.305, 6.413]

cubicSplineInstance = interpolate.CubicSpline(t, o)


y_cap = cubicSplineInstance(t)

plt.plot(t, o, 'o', t, y_cap)
print('Cubic Spline for 4 and 36:', cubicSplineInstance([4, 36]))

"""## Worksheet3

### Problem1
"""

x = [200, 250, 200, 250, 189.65, 260.35, 225, 225, 225, 225, 225, 225]
y = [43, 78, 69, 73, 48, 78, 65, 74, 76, 79, 83, 81]

a, b = LinearRegression(x, y)
y_cap = [((a*i)+b) for i in x]

print(f'Line equation y = {a}x + ({b})')

fig = plt.figure(figsize=(20,8))
plt.scatter(x, y, label = "x versus y")
plt.plot(x, y_cap, label = "x versus y_cap")
plt.legend()
sse, sst, correlation = CalculateMeasures(y,y_cap)

print("Correlation: ", correlation)
print("SSE: ", sse)
print("SST: ", sst, '\n')

"""### Problem2"""

emitterDriveIn = [195, 255, 195, 255, 255, 255, 255, 195, 255, 255, 255, 255, 255, 340]
emitterDose = [4.0, 4.0, 4.6, 4.6, 4.2, 4.1, 4.6, 4.3, 4.3, 4.0, 4.7, 4.3, 4.72, 4.3]
y = [1004, 1636, 852, 1506, 1272, 1270, 1269, 903, 1555, 1260, 1146, 1276, 1225, 1321]

a, b = LinearRegression(emitterDriveIn, y)

print(f'Line equation for emitterDriveIn y = {a}x + ({b})')
y_cap = [((a*i)+b) for i in emitterDriveIn]

fig, axs = plt.subplots(2, figsize=(15, 10))

print("Null hypothesis: y_cap and y are equal - model is fitting")
print("Alternate hypothese: y_cap and y are not equal - model is not fitting")

t, p1 = stats.ttest_ind(y, y_cap)
print(f"\nT-test values - t: {t}, p: {p1}")

print("Threshold: 5%")

if(p1 > 0.05):
    print("Null hypothesis is not rejected")
else:
    print("Null hypothesis is accepted")

axs[0].scatter(emitterDriveIn, y, label = "Original")
axs[0].plot(emitterDriveIn, y_cap, label = "Predicted")
axs[0].set_title('emitterDriveIn vs Y')
axs[0].legend()

a, b = LinearRegression(emitterDose, y)
print(f'Line equation for emitterDose y = {a}x + ({b})')
y_cap = [((a*i)+b) for i in emitterDose]

t, p2 = stats.ttest_ind(y, y_cap)
print(f"\nT-test values - t: {t}, p: {p2}")
print("Threshold: 5%")
#trend
if(p2 > 0.05):
    print("Null hypothesis is not rejected")
else:
    print("Null hypothesis is accepted")

axs[1].scatter(emitterDose, y, label = "Original")
axs[1].plot(emitterDose, y_cap, label = "Predicted")
axs[1].set_title('emitterDose vs Y')
axs[1].legend()

if p1 > p2:
  print("\nDrive-in influences gain more\n")
else:
  print("\nDose influences gain more\n")

"""### Problem3"""

year = [1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999]
no = np.array([0.73, 2.55, 2.9, 3.83, 2.53, 2.77, 3.93, 2.03, 4.39, 3.04, 2.41, 5.07, 2.95, 3.14, 3.44, 3.63, 4.5, 3.95, 5.24, 3.3, 4.36, 3.33])


fig, axs = plt.subplots(2, figsize = (20, 20))
axs[0].plot(year, no, label = 'Year versus Nitrogen Oxide')
axs[0].legend()
axs[0].set_title('Year versus Nitrogen Oxide')

a, b = LinearRegression(year, no)

print(f'Line equation y = {a}x + ({b})')

y_cap = np.array([((a*i)+b) for i in year])

error = no - y_cap

axs[1].plot(year, no, 'o', year, no, label = "Year vs NO")
axs[1].plot(year, error, 'k', label = "Year vs Error")
axs[1].plot(year, y_cap, 'g', label = "Year vs Predicted NO")
axs[1].set_title("Linear regression Plot")
axs[1].legend()

sse, sst, correlation = CalculateMeasures(y,y_cap)

print("\nR square: ", correlation**2)

print("\nNull hypothesis: y_cap and y are equal - model is fitting")
print("Alternate hypothese: y_cap and y are not equal - model is not fitting")
t, p2 = stats.ttest_ind(y, y_cap)
print(f"T-test values - t: {t}, p: {p2}")

print("Threshold: 5%")
#trend
if(p2 > 0.05):
    print("\nNull hypothesis is not rejected\n")
else:
    print("\nNull hypothesis is accepted\n")

"""### Problem 4"""

# P = aV^b
v = np.array([2.27, 2.76, 3.27, 3.31, 3.7, 3.85, 4.31, 4.39, 4.42, 4.81, 4.9, 5.05, 5.21, 5.62, 5.88])
p = np.array([2500, 365, 23700, 5491, 14000, 78200, 70700, 138000, 304500, 341948, 49375, 260200, 867023, 1340000, 1092759])

lnV = np.log(v)
lnP = np.log(p)

fig, axs = plt.subplots(3, figsize = (20, 12))

axs[0].plot(v, p, 'o', v, p, label = "P vs V")
axs[0].legend()

axs[1].plot(lnV, lnP, 'o', lnV, lnP, label = "Ln P vs Ln V")
axs[1].legend()

b, a = LinearRegression(lnV, lnP)

y_cap = [math.exp(b*i + a) for i in lnV]

axs[2].scatter(v, p, label = "Original Data")
axs[2].plot(v, y_cap, 'orange', label = "Regression curve")
axs[2].legend()

# P = a ln(V)

v = np.array([2.27, 2.76, 3.27, 3.31, 3.7, 3.85, 4.31, 4.39, 4.42, 4.81, 4.9, 5.05, 5.21, 5.62, 5.88])
p = np.array([2500, 365, 23700, 5491, 14000, 78200, 70700, 138000, 304500, 341948, 49375, 260200, 867023, 1340000, 1092759])

lnV = np.log(v)

fig, axs = plt.subplots(3, figsize = (20, 12))

axs[0].plot(v, p, 'o', v, p, label = "P vs V")
axs[0].legend()

axs[1].plot(lnV, p, 'o', lnV, p, label = "P vs Ln V")
axs[1].legend()

b, a = LinearRegression(lnV, p)

print(b, a)

y_cap = [b*i + a for i in lnV]

axs[2].scatter(v, p, label = "Original Data")
axs[2].plot(v, y_cap, 'orange', label = "Regression curve")
axs[2].legend()

"""### Problem5"""

# T =Cr^a
r = [57.9,108.2,149.6,227.9,778.1,1428.2,2837.9,4488.9]
t = [88,225,365,687,4329,10753,30660,60150]

fig, axs = plt.subplots(2, figsize=(20, 9))

axs[0].plot(r, t, 'o', r, t, label = 'r vs T')
axs[0].legend()
lnR = np.log(r)
lnT = np.log(t)

a, b = LinearRegression(lnR, lnT)

yCap = [(a*i + b) for i in lnR]
axs[1].plot(lnR, lnT, 'o', lnR, yCap, label = "ln R vs ln T")
axs[1].legend()

"""## Worksheet 5

### Problem1
"""

year = [1989, 1990, 1991, 1992, 1993, 1994, 1995]
boxes = [21, 19.4, 22.6, 28.2, 30.4, 24.0, 25]


a, b = LinearRegression(year, boxes)
print(f'Line equation y = {round(a, 3)}x + {round(b, 3)}')

Yboxes = [b + a * x for x in year]
print(Yboxes)
trend = [round((boxes[i] / Yboxes[i]) * 100, 2)  for i in range(len(boxes))]

relativeTrend = [round(val - 100, 2) for val in trend]

print('Cyclic variation:', trend)
print('Relative Cyclic variation:', relativeTrend)
print('Trend fluctuation -> year:', year[trend.index(max(trend))])
plt.figure(figsize = (12, 8))
plt.plot(year, boxes, 'o', year, boxes, label = "Original")
plt.plot(year, Yboxes, 'o', year, Yboxes, label = "Predicted")
plt.legend()

"""### Problem 2"""

actual_sales = [102, 120, 90, 78, 110, 126, 95, 83, 111, 128, 97, 86, 115, 135, 103, 91, 122, 144, 110, 98]

ComputeSeasonalIndex(actual_sales, 5)

"""### Problem3"""

actual_sales = [5.6, 6.8, 6.3, 5.2, 5.7, 6.7, 6.4, 5.4, 5.3, 6.6, 6.1, 5.1, 5.4, 6.9, 6.2, 5.3]

re = ComputeSeasonalIndex(actual_sales, 4)

plt.figure(figsize=(12, 8))
plt.plot(actual_sales, label="Actual")
plt.plot(re['four_quarter_centered_moving_avg'], label='Four Quarter Centered Moving Avg')
plt.legend()

"""### Problem4"""

actual_sales = [293, 246, 231, 282, 301, 252, 227, 291, 304, 259, 239, 296, 306, 265, 240, 300]

re = ComputeSeasonalIndex(actual_sales, 4)

# For Fitting data 
coeff = IdentifyTrend(re['deseasonalized_data'], 4)

YCap = predict_val(coeff['a'], coeff['b'], coeff['coding'])

trend = [round((re['deseasonalized_data'][i] / YCap[i]) * 100, 5) for i in range(len(YCap))]
relativeTrend = [round(((re['deseasonalized_data'][i] - YCap[i]) / YCap[i]) * 100, 5) for i in range(len(YCap))]

print("Trend", trend)
print("Relative Trend", relativeTrend)
plt.figure(figsize=(13, 10))
plt.title('Trend plot')
plt.plot(actual_sales, label="actual")
plt.plot(YCap, label="Predicted")
plt.plot(re['deseasonalized_data'], '--', label="deseasonalized")
plt.legend()
plt.show()

plt.figure(figsize=(20, 1))
plt.plot(trend, label="Trend")

